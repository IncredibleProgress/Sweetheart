
from collections import UserList
from sweetheart.snippets import *


class WebappServer(UserList):

    def __init__(self,config:BaseConfig):
        
        self.data = []
        self.config = config
        self.middleware = None #FIXME

    def mount(self,*args:str|Route):

        """ [Deprecated]
        Mounting str args is used as presets for set_service(),
        and str args must describe here Route|Mount correct instances.
        Otherwise mounting Route|Mount is used to build Starlette app. """

        args_are: bool = lambda typ:\
            all([ isinstance(arg,typ) for arg in args ])
            # True when all args are instances of typ

        if args_are(str):
            assert not self.data
            assert not hasattr(self,"mount_str_")
            self.mount_str_ = ",\n".join(args)
            try: [ eval(string) for string in args ]
            except: raise Exception("Invalid string given to mount()")

        elif args_are((Route,)):
            assert not hasattr(self,"mount_str_")
            self.data.extend(args)
        
        else:
            raise Exception("Invalid args given to mount()")

        return self

    def app(self,*args:Route) -> Asgi3App:

        self.mount(*args)

        return Asgi3App(
            routes = self.data,
            debug = BaseConfig.debug,
            middleware = self.middleware )

    def set_service(self,put_config=False):

        assert hasattr(self,"mount_str_")
        path = self.config.path_pymodule
        module = self.config.python_app_module

        with open(f"{path}/{module}.py",'w') as python_script:
            python_script.write(
f'''
"""
{self.config.python_app_module}.py
auto-generated by sweetheart.services.WebappServer
[USER:] {os.getuser()} [DATE:] {os.stdout("date")}
"""
from sweetheart.services import *

config = set_config()

{self.config.python_app_callable} = WebappServer(config).app(
    # set here url routing of your sweetheart app
    {self.mount_str_} )
''')
        # set NGINX Unit config for app
        unit = NginxUnit()
        unit.set_app_config(self.config)
        if put_config: unit.put_config()


class NginxUnit(UserDict):        

    def __init__(self):

        self.data = {}
        self.host = "http://localhost"
        self.socket = "/var/run/control.unit.sock"

    def set_app_config(self,config:BaseConfig):

        self.unitconf = f"{config.root}/configuration/unit.json"

        with open(self.unitconf) as file_in:
            self.update(json.load(file_in))

        try:
            app = self["applications"][config.unit_app_name]
        except:
            raise Exception("Invalid Unit settings 'applications'")
            
        app.update({
            "path": config.path_pymodule,
            "home": config.python_env,
            "module": config.python_app_module,
            "callable": config.python_app_callable,
            "user": config.unit_app_user })

        try:
            route = self["routes"][-1]["action"]
        except:
            raise Exception("Invalid Unit settings 'routes'")

        route.update({
            "share": f"{config.shared_app_content}$uri",
            "chroot": config.shared_app_content,
            "index": config.shared_app_index })
            
    def put_config(self):

        assert self["listeners"]
        assert self["routes"]
        assert self["applications"]

        echo("configuring NGINX Unit ...")
        verbose("unit config:",self.data,level=2)

        with os.NamedTemporaryFile("wt",delete=False) as tempfile:
            json.dump(self.data,tempfile)
            tempname = tempfile.name

        stdout = eval(os.stdout( ["sudo",
            "curl","-X","PUT","-d",f"@{tempname}",
            "--unix-socket",self.socket,f"{self.host}/config/"]
            )); assert isinstance(stdout,dict)

        os.remove(tempname)
        
        verbose("set unit:",
            ansi.GREEN, stdout.get('success',''),
            ansi.RED, stdout.get('error',''),
            level=0 )

        os.run("sudo systemctl reload-or-restart unit")


class RethinkDB(
    xUrl,xWebsocket,xSystemd ):

    def __init__(self,config:BaseConfig):
        
        self.config = config
        self.urlparse("config.database_server")

    def set_client(self,dbname:str=None):

        # [LocalImport]
        from rethinkdb import r

        if hasattr(self,'conn'):
            echo("existing RethinkDB connection closed",prefix=ansi.RED)
            self.conn.close()

        if dbname is None:
            dbname= self.config.db_name

        self.dbname = dbname
        self.client = self.r = r
        self.conn = r.connect(self.host,self.port,db=dbname)

        return self.client

    def set_service(self,enable:str=None):

        dirpth = self.config.path_database
        adport = urlparse(self.config.database_admin).port

        self.set_systemd_service({

            "Unit": {
                "Description": "RethinkDB running for Sweetheart app",
                "After": "network.target" },

            "Service": {
                "ExecStart": f"rethinkdb --http-port {adport} -d {dirpth}",
                "Restart": "always",
                "StandardOutput": "syslog",
                "StandardError": "syslog",
                "SyslogIdentifier": "sweetheart-app",
                "User": os.getuser(),
                "Group": os.getuser() },#FIXME

            "Install": {
                "WantedBy": "multi-user.target" } })
        
        if enable:
            self.enable_systemd_service(enable)

    # def on_receive(self,websocket,data):
    #     raise NotImplementedError

    def __del__(self):
        # close last RethinkDB connection
        if hasattr(self,'conn'): self.conn.close()
    