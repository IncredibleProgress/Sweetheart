from sweetheart import *
from typing import Self
from pathlib import Path
from rethinkdb import RethinkDB as R
from sweetheart.systemctl import Unit, Systemd

from sweetheart.asgi3 import (
    AsgiLifespanRouter, Route, DataHub, 
    Websocket, JSONResponse, JSONMessage )


class WebappServer(Unit):

    def __init__(self,config:BaseConfig):
        
        self.data = []
        self.config = config
        self.middelware = None #FIXME

        # keep current app config available 
        WebappServer._config_ = config

    def mount(self,
        *args: Route|DataHub ) -> Self:

        # unrelevant instances forbidden
        allow = (Route,DataHub)
        assert all([isinstance(arg,allow) for arg in args])
        
        self.data.extend(args)
        return self

    def app(self,
        *args: Route|DataHub ) -> AsgiLifespanRouter:

        """ Return ASGI app built from given args, callable by NginxUnit. 
            Intends to keep some consistency with https://www.starlette.io."""

        # mount args with mount() or app() but not both
        if args:
            assert self.data == []
            self.mount(*args)
        
        routes = self.data
        del self.data#! new mount forbidden

        return AsgiLifespanRouter(
            routes = routes,
            debug = BaseConfig.debug,
            middelware = self.middelware )

    def set_service(self,unit=False):

        pyconf = self.config["python_app"]
        pyfile = Path(pyconf['path']) / f"{pyconf['module']}.py"

        pyfile.parent.mkdir(parents=True,exist_ok=True) #FIXME
        pyfile.write_text(self.generate_python_script(pyconf))

        if unit:
            # force new NginxUnit config
            self.load_unit_config(source="json")
            self.set_unit_config(share_directory=True)
            Unit.put_unit_config()

    @staticmethod
    def generate_python_script(pyconf:dict):

        return f"""# {pyconf["module"]}.py
# auto-generated by sweetheart.services.WebappServer
# USER: {os.getuser()} DATE: {os.stdout("date")}
from sweetheart.services import *

config = set_config({{
    # set here your app config
    # empty values are auto-set
}})

{pyconf["callable"]} = WebappServer(config).app(
    # set here url routing for your app
    # default is a rethinkdb data driver at /data
    DataHub("/data", RethinkDB()),
)"""


class DataSystem(Systemd): #FIXME
    """ Interface for database wrappers. """

    # set Rest Api methods
    #NOTE: asgi/unit uppercases http methods
    restapi = { "GET": self.on_GET }

    def connect(self,options={}):
        """ Connect to database. """
        raise NotImplementedError

    def on_GET(self,data:dict) -> JSONResponse:
        """ Handle http get request. """
        raise NotImplementedError

    def on_receive(self,data:dict) -> JSONMessage:
        """ Handle incoming websocket message. """
        raise NotImplementedError

    def set_service(self) -> None:
        """ Set systemd service for database. """
        raise NotImplementedError


class RethinkDB(Systemd):

    def __init__(self,
            config: BaseConfig = None ):
        
        if config is None:
            # auto-set current app config
            config = WebappServer._config_

        self.r = R()
        self.rconfig = config["rethinkdb"]

        self.restapi = {
            #NOTE: methods are uppercased
            "GET": self.on_GET,
            # "PUT": self.on_put,
            "PATCH": self.on_PATCH,
            "POST": self.on_POST }

    def connect(self,options={}):

        kwargs = dict(
            #NOTE: rethinkdb set default db="test"
            host = "localhost",
            port = self.rconfig["driver-port"] )

        kwargs.update(options)
        self.conn = self.r.connect(**kwargs)
        return self.conn

    def run_expr(self,query:str,conn=None):
        """ Run given RethinkDB query. """

        if not conn: conn = self.conn
        return self.r.expr(query).run(conn)

    def on_receive(self,data:dict) -> JSONMessage | None:
        
        if data.get("action")[:7] == "ws.rest":
            # hook to reuse Rest Api methods with websocket
            method = data["action"][8:].upper()# ws.rest.get -> GET 
            feedback = self.datasystem.restapi[method](data)

            if isinstance(feedback,JSONResponse):
                #NOTE: hook to accept http JSONResponse
                return JSONMessage(feedback.bjson,type="bytes")

        elif data.get("action") == "ws.reql":
            # execute any RethinkDB query (development only)
            assert os.getenv("SWS_OPERATING_STATE") == "development"
            cursor = self.r.expr(data["query"]).run(self.conn)
            self.websocket.send_bjson(list(cursor))

        else: return JSONMessage({
            "Err": "Invalid websocket action." })

    def on_GET(self,d:dict) -> JSONResponse:
        # Rest Api: GET
        r = self.r.table(d["table"])
        if d.get("filter"): r.filter(d["filter"])
        cursor: r.net.Cursor = r.run(self.conn)
        return JSONResponse(list(cursor))

    def on_POST(self,d:dict):
        # Rest Api: POST
        r = self.r.table(d["table"])
        r.insert(d["row"]).run(self.conn)
            
    def on_PATCH(self,d:dict):
        # Rest Api PATCH
        r = self.r.table(d["table"]).get(d["id"])
        r.update({d["field"]: d["value"]}).run(self.conn)

    # def def on_put(self,d:dict):
    #     # Rest Api PUT
    #     r = self.r.table(d["table"])
    #     r.get(d["id"]).replace(d["data"]).run(self.connect)

    # def on_delete(self,d:dict):
    #     # Rest Api DELETE
    #     r = self.r.table(d["table"])
    #     r.get(d["id"]).delete().run(self.connect)

    def set_service(self,enable:str=None):

        ExecStart = " ".join(["rethinkdb",
            *[f"--{k} {v}" for k,v in self.rconfig.items()] ])

        self.set_systemd_service({
            "Unit": {
                "Description": "RethinkDB running for Sweetheart",
                "After": "network.target" },
            "Service": {
                "ExecStart": ExecStart,
                "Restart": "always",
                "User": os.getuser(),#FIXME
                "Group": os.getuser() },#FIXME
                "WorkingDirectory": f"{self.root}/databases",#FIXME
            "Install": {
                "WantedBy": "multi-user.target" } })
        
        if enable is not None:
            assert isinstance(enable,str)
            self.enable_systemd_service(enable)

    def __del__(self):

        if hasattr(self,"conn"):
            self.conn.close()


# --- --- Legacy Code --- ---

# def mount(self,*args:str|Route|DataHub) -> Self:

    #     def args_are(typ):
    #         # return True when all args are instances of typ
    #         return all([isinstance(arg, typ) for arg in args])

    #     if args_are(str):
    #         assert not self.data
    #         assert not hasattr(self,"mount_str_")
    #         self.mount_str_ = ",\n".join(args)

    #     elif args_are((Route,DataHub)):
    #         assert not hasattr(self,"mount_str_")
    #         self.data.extend(args)
        
    #     else:
    #         raise Exception("Invalid args given to mount()")

    #     return self