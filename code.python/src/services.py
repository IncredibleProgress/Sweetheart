from sweetheart import *
from typing import Self
# from rethinkdb import RethinkDB as R
from sweetheart.systemctl import Unit, Systemd

from sweetheart.asgi3 import (
    AsgiLifespanRouter, DataHub, Route, 
    Websocket, JSONResponse, JSONMessage )


class WebappServer(Unit):

    def __init__(self, config:BaseConfig):
        
        self.data = []
        self.config = config
        self.middleware = [] #FIXME

        # allow testing python apps
        self.PythonAppType = AsgiLifespanRouter

        # keep current app config available 
        WebappServer._config_ = config

    def mount(self, *args: Route|DataHub ) -> Self:

        # unrelevant instances forbidden
        allowed = (Route,DataHub)
        assert all([isinstance(arg,allowed) for arg in args])
        
        self.data.extend(args)
        return self

    def app(self, *args: Route|DataHub ) -> AsgiLifespanRouter:

        """ Return ASGI app built from given args, callable by NginxUnit. 
            Intends to keep some consistency with https://www.starlette.io."""

        # mount args with mount() or app() but not both
        if args:
            assert self.data == []
            self.mount(*args)
        
        routes = self.data
        del self.data #! new mount forbidden

        return self.PythonAppType(
            routes = routes,
            debug = BaseConfig.debug,
            middleware = self.middleware )

    def set_service(self, unit=False):

        pyconf = self.config["python_app"]
        pyfile = f"{pyconf['path']}/{pyconf['module']}.py"

        pyfile.parent.mkdir(parents=True,exist_ok=True) #FIXME
        pyfile.write_text(self.generate_python_script(pyconf))

        if unit is True:
            # force new NginxUnit config
            self.load_unit_config(source="json")
            self.set_unit_config(share_directory=True)
            Unit.put_unit_config()

    @staticmethod
    def generate_python_script(pyconf:dict):

        return f"""# --- start Python3 script --- #

# Information:
# auto-generated by sweetheart.services.WebappServer
# [ USER: {os.getuser()} ] [ DATE: {os.stdout("date")} ]

# Import Sweetheart Services:
from sweetheart.services import *

# Set App Configuration:

config = set_config({{
    # set here your own app config when required
    # but please refer to the documentation first
}})

# Set Python Asgi/3 App for data:

# create here a runable entry point for your data traffic
# default and recommended is a PostgresUnchained data driver at the url /geldata
# NOTE: Sweetheart aims to serve statics directly via NginxUnit, not Asgi/3

{pyconf["callable"]} = WebappServer(config).app(
    # DataHub("/data", RethinkDB()) #! deprecated
    DataHub("/geldata", PostgresUnchained()),
)

# --- end of script --- #"""


class PostgresUnchained(Systemd):
    #FIXME: incomplete, untested

    def __init__(self, config:BaseConfig=None):
        
        if config is None:
            # inherit config from WebappServer
            config = WebappServer._config_

        # set default config for single instance
        self.pgconfig: dict = config["postgres"] # cli options
        self.project: str = config["database_project"]

        self.restapi = {
            #NOTE: methods are uppercased
            "GET": self._edgeQL_SELECT,
            "POST": self._edgeQL_INSERT,
            "PATCH": self._edgeQL_UPDATE,
            # "PUT": self.edgeQL_REPLACE,
            # "DELETE": self.edgeQL_DELETE
        }

    def connect(self,settings={}):
        
        from gel import create_client # [LocalImport]
        assert isinstance(settings,dict)

        #FIXME: set default settings as kwargs
        kwargs = dict()
        kwargs.update(settings)

        os.chdir(self.project)
        self.client = create_client(**kwargs)
        self.client.ensure_connected()

        return self.client

    def _edgeQL_SELECT(self,d:dict,client=None) -> tuple:
        
        if client is None:
            client = self.client

        query = client.query(f"""
            select {d['table']};
        """)

        # return result as tuple (status, value)
        return "Ok", query

    def _edgeQL_INSERT(self,d:dict,client=None) -> tuple:

        if client is None:
            client = self.client

        # convert dict to edgeQL object notation
        data = ", ".join([
            f"{k}: {v if isinstance(v,(int,float)) else f'\"{v}\"'}" \
            for k,v in d["row"].items() ])

        # ensure data is not empty
        assert data != ""

        query = client.query(f"""
            insert {d['table']} {{ {data} }};
        """)

        # return result as tuple (status, value)
        return "Ok", query

    def _edgeQL_UPDATE(self,d:dict,client=None) -> tuple:

        if client is None:
            client = self.client

        if isinstance(d["value"],str):
            d["value"] = f'"{d["value"]}"' # add quotes

        query = client.query(f"""
            update {d['table']}
            filter .id = {d['id']}
            set {{ .{d['name']} := {d['value']} }};
        """)

        # return result as tuple (status, value)
        return "Ok", query

    def set_service(self,enable:str=None):
        raise NotImplementedError


# --- --- --- legacy --- --- --- #

# class RethinkDB(Systemd):

#     def __init__(self, config:BaseConfig=None):
        
#         if config is None:
#             # inherit config from WebappServer
#             config = WebappServer._config_

#         # set default config for single instance
#         self.rconfig: dict = config["rethinkdb"] # cli options
#         self.allow_databases: list = config["allow_databases"]

#         self.restapi = {
#             #NOTE: methods are uppercased
#             "GET": self._rql_FILTER,
#             "POST": self._rql_INSERT,
#             "PATCH": self._rql_UPDATE,
#             # "PUT": self.rql_REPLACE,
#             # "DELETE": self.rql_DELETE
#         }

#     def connect(self, settings={}):
#         """ Start new connection with RethinkDB server. """

#         assert isinstance(settings,dict)

#         # set default settings as kwargs
#         kwargs = dict(
#             db = "test",
#             host = "localhost",
#             port = self.rconfig["driver-port"] )

#         kwargs.update(settings)
#         assert kwargs["db"] in self.allow_databases # safer

#         # connect to RethinkDB server
#         if not hasattr(self,"r"): self.r = R()
#         connect = self.r.connect(**kwargs)

#         if not hasattr(self,"conn"):
#             #NOTE: keep 1st connection as attribute
#             self.conn = connect
            
#         return connect

#     # def _rql_expr(self, query:str, conn=None) -> tuple:
#     #     """ Run any given RethinkDB query. """

#     #     # set default connection
#     #     if not conn: conn = self.conn
#     #     # return result as tuple (status, value)
#     #     return "Ok", self.r.expr(query).run(conn) #FIXME

#     def _rql_FILTER(self, d:dict, conn=None) -> tuple:

#         if conn is None:
#             conn = getattr(self,"conn",
#                 # default: set conn establishing a first connection
#                 # this assumes that rql_FILTER is used first for fetching data
#                 # when 'db' is None, a default value is provided in self.connect()
#                 self.connect({ "db": d.get("database",default=None) }) )

#         if d.get("database"):
#             assert d["database"] in self.allow_databases
#             r = self.r.db(d["database"])
#         else:
#             r = self.r # means db is provided by conn
                
#         # apply Rest Api: GET
#         r = r.table(d["table"])
#         if d.get("filter"): r = r.filter(d["filter"])

#         # return result as tuple (status, value)
#         return "Ok", list(r.run(conn))

#     def _rql_INSERT(self, d:dict, conn=None) -> tuple:

#         # set default connection
#         if conn is None:
#             conn = self.conn

#         if d.get("database"):
#             assert d["database"] in self.allow_databases
#             r = self.r.db(d["database"])
#         else:
#             r = self.r # means db provided by conn

#         # apply Rest Api: POST
#         query = r.table(d["table"]).insert(d["row"]).run(conn)

#         # return result as tuple (status, value)
#         if query["errors"]: return ("Err",query["errors"])
#         elif query["inserted"]==1: return ("Ok",None)
#         else: return ("Err","No data inserted")

#     def _rql_UPDATE(self, d:dict, conn=None) -> tuple:

#         # set default connection
#         if conn is None:
#             conn = self.conn

#         if d.get("database"):
#             assert d["database"] in self.allow_databases
#             r = self.r.db(d["database"])
#         else:
#             r = self.r # means db provided by conn

#         # Rest Api: PATCH
#         query = r.table(d["table"]).get(d["id"]) \
#             .update({ d["name"]: d["value"] }).run(conn)
            
#         # return result as tuple (status, value)
#         if query["errors"]: return "Err",query["errors"]
#         elif query["replaced"]==1: return "Ok",None
#         else: return "Err","No data updated"

#     # def def ReQL_REPLACE(self,d:dict):
#     #     # Rest Api: PUT
#     #     r = self.r.table(d["table"])
#     #     r.get(d["id"]).replace(d["data"]).run(self.connect)

#     # def ReQL_DELETE(self,d:dict):
#     #     # Rest Api DELETE
#     #     r = self.r.table(d["table"])
#     #     r.get(d["id"]).delete().run(self.connect)

#     def set_service(self,enable:str=None):

#         ExecStart = " ".join(["rethinkdb",
#             *[f"--{k} {v}" for k,v in self.rconfig.items()] ])

#         self.set_systemd_service({
#             "Unit": {
#                 "Description": "RethinkDB running for Sweetheart",
#                 "After": "network.target" },
#             "Service": {
#                 "ExecStart": ExecStart,
#                 "Restart": "always",
#                 "User": os.getuser(),#FIXME
#                 "Group": os.getuser() },#FIXME
#                 "WorkingDirectory": f"{self.root}/databases",#FIXME
#             "Install": {
#                 "WantedBy": "multi-user.target" } })
        
#         if enable is not None:
#             assert isinstance(enable,str)
#             self.enable_systemd_service(enable)

#     def __del__(self):
#         """ Close default connection when object is deleted. """
#         #NOTE: multiple connections must be managed explicitly
#         if hasattr(self,"conn"): self.conn.close()
